[mod] gstreamer1.0-plugins-bad (h264parse, h265parse, h265parser)

h264parse - 1) enable passthrough
            2) Add an error-concealment scheme for wrong avcC format
            3) VPU can support up to the h264 profile up to high level 4.2. if over spec of profile, return error.
h265parse - enable passthrough
h265parser - H265 parser does not check VUI parsing error, it can be reconfirmed in VPU.

diff -Naur 1.20.3-r0/gst-plugins-bad-1.20.3/gst/videoparsers/gsth264parse.c after/gst/videoparsers/gsth264parse.c
--- 1.20.3-r0/gst-plugins-bad-1.20.3/gst/videoparsers/gsth264parse.c	2022-06-16 07:36:22.000000000 +0900
+++ after/gst/videoparsers/gsth264parse.c	2022-11-07 17:22:23.239467491 +0900
@@ -39,7 +39,7 @@
 
 #define DEFAULT_CONFIG_INTERVAL      (0)
 #define DEFAULT_UPDATE_TIMECODE       FALSE
-
+#define ENABLE_ERROR_CONCEALMENT //error concealment for wrong encoded stream
 enum
 {
   PROP_0,
@@ -938,7 +938,7 @@
   GstH264SliceHdr slice;
 
   /* nothing to do for broken input */
-  if (G_UNLIKELY (nalu->size < 2)) {
+  if (G_UNLIKELY (nalu->size < 2) || (nalu->size == -1)) {
     GST_DEBUG_OBJECT (h264parse, "not processing nal size %u", nalu->size);
     return TRUE;
   }
@@ -1051,7 +1051,8 @@
       h264parse->state &= GST_H264_PARSE_STATE_VALID_PICTURE_HEADERS;
       if (!GST_H264_PARSE_STATE_VALID (h264parse,
               GST_H264_PARSE_STATE_VALID_PICTURE_HEADERS))
-        return FALSE;
+        GST_WARNING_OBJECT(h264parse, "Expected state is %x, but Current state is %x. anyway continue..",
+                                       GST_H264_PARSE_STATE_VALID_PICTURE_HEADERS,h264parse->state);
 
       /* This is similar to the GOT_SLICE state, but is only reset when the
        * AU is complete. This is used to keep track of AU */
@@ -3348,6 +3349,8 @@
   GstH264NalUnit nalu;
   GstH264ParserResult parseres;
   GstCaps *old_caps;
+  gboolean passthrough = FALSE;
+  guint8 profile_idc = 0, level_idc = 0;
 
   h264parse = GST_H264_PARSE (parse);
 
@@ -3371,6 +3374,8 @@
   gst_structure_get_fraction (str, "pixel-aspect-ratio",
       &h264parse->upstream_par_n, &h264parse->upstream_par_d);
 
+  /* check if upstream want to do passthrough mode */
+  gst_structure_get_boolean (str, "ring-mode", &passthrough);
   /* get upstream format and align from caps */
   gst_h264_parse_format_from_caps (caps, &format, &align);
 
@@ -3392,8 +3397,14 @@
   /* avc caps sanity checks */
   if (format == GST_H264_PARSE_FORMAT_AVC) {
     /* AVC requires codec_data, AVC3 might have one and/or SPS/PPS inline */
-    if (codec_data_value == NULL)
+    if (codec_data_value == NULL) {
+#ifdef ENABLE_ERROR_CONCEALMENT
+      GST_INFO_OBJECT (h264parse, "avc_caps_codec_data_missing");
+      goto invalid_avcC_format;
+#else
       goto avc_caps_codec_data_missing;
+#endif
+    }
 
     /* AVC implies alignment=au, everything else is not allowed */
     if (align == GST_H264_PARSE_ALIGN_NONE)
@@ -3437,12 +3448,21 @@
     /* parse the avcC data */
     if (size < 7) {             /* when numSPS==0 and numPPS==0, length is 7 bytes */
       gst_buffer_unmap (codec_data, &map);
+#ifdef ENABLE_ERROR_CONCEALMENT
+      GST_INFO_OBJECT (h264parse, "avcc_too_small %d", size);
+      goto invalid_avcC_format;
+#else
       goto avcc_too_small;
+#endif
     }
     /* parse the version, this must be 1 */
     if (data[0] != 1) {
       gst_buffer_unmap (codec_data, &map);
+#ifdef ENABLE_ERROR_CONCEALMENT
+      goto invalid_avcC_format;
+#else
       goto wrong_version;
+#endif
     }
 #ifndef GST_DISABLE_GST_DEBUG
     /* AVCProfileIndication */
@@ -3452,6 +3472,21 @@
     GST_DEBUG_OBJECT (h264parse, "profile %06x", profile);
 #endif
 
+    /* VPU decoder can support up to H264 High profile @Level 4.2 */
+    profile_idc = data[1];
+    level_idc = data[3];
+
+    if( profile_idc < 66 || profile_idc > 100)
+    {
+      GST_WARNING_OBJECT (h264parse, "Video decoder can support up to H264 High profile @Level 4.2");
+      goto not_support_profile;
+    }
+    if( (profile_idc == 100) && level_idc > 42)
+    {
+      GST_ELEMENT_WARNING (h264parse, LIBRARY, SPEC_OUT,
+       (("Video decoder can quarantee up to H264 High profile @Level 4.2.\n This stream is H264 profile[%d] @Level[%d], therefore it can be played abnormally"), profile_idc, level_idc), NULL);
+    }
+
     /* 6 bits reserved | 2 bits lengthSizeMinusOne */
     /* this is the number of bytes in front of the NAL units to mark their
      * length */
@@ -3500,6 +3535,9 @@
     h264parse->have_sps_in_frame = FALSE;
     h264parse->have_pps_in_frame = FALSE;
   } else if (format == GST_H264_PARSE_FORMAT_BYTE) {
+#ifdef ENABLE_ERROR_CONCEALMENT
+CONTINUE_PARSING_ON_FORMAT_BYTE:
+#endif
     GST_DEBUG_OBJECT (h264parse, "have bytestream h264");
     /* nothing to pre-process */
     h264parse->packetized = FALSE;
@@ -3524,7 +3562,9 @@
     gst_caps_unref (in_caps);
   }
 
-  if (format == h264parse->format && align == h264parse->align) {
+  if ( (format == h264parse->format && align == h264parse->align) || passthrough) {
+    gst_base_parse_set_passthrough (parse, TRUE);
+
     /* we did parse codec-data and might supplement src caps */
     gst_h264_parse_update_src_caps (h264parse, caps);
   } else if (format == GST_H264_PARSE_FORMAT_AVC
@@ -3545,6 +3585,18 @@
   return TRUE;
 
   /* ERRORS */
+#ifdef ENABLE_ERROR_CONCEALMENT
+invalid_avcC_format:
+  {
+      format = GST_H264_PARSE_FORMAT_BYTE;
+      GST_WARNING_OBJECT (h264parse, "**************************************************************************");
+      GST_WARNING_OBJECT (h264parse, "");
+      GST_WARNING_OBJECT (h264parse, "  Invalid avcC Format: Let's treat it as a bytestream format");
+      GST_WARNING_OBJECT (h264parse, "");
+      GST_WARNING_OBJECT (h264parse, "**************************************************************************");
+      goto CONTINUE_PARSING_ON_FORMAT_BYTE;
+  }
+#endif
 avc_caps_codec_data_wrong_type:
   {
     GST_WARNING_OBJECT (parse, "H.264 AVC caps, codec_data field not a buffer");
@@ -3576,6 +3628,11 @@
     GST_DEBUG_OBJECT (h264parse, "wrong avcC version");
     goto refuse_caps;
   }
+not_support_profile:
+  {
+    GST_ELEMENT_WARNING (h264parse, LIBRARY, SPEC_OUT, (("Video decoder can not support H264 profile[%d] @Level[%d]"), profile_idc, level_idc), NULL);
+    goto refuse_caps;
+  }
 refuse_caps:
   {
     GST_WARNING_OBJECT (h264parse, "refused caps %" GST_PTR_FORMAT, caps);
diff -Naur 1.20.3-r0/gst-plugins-bad-1.20.3/gst/videoparsers/gsth265parse.c after/gst/videoparsers/gsth265parse.c
--- 1.20.3-r0/gst-plugins-bad-1.20.3/gst/videoparsers/gsth265parse.c	2022-06-16 07:36:22.000000000 +0900
+++ after/gst/videoparsers/gsth265parse.c	2022-11-07 17:25:02.417623183 +0900
@@ -3047,6 +3047,8 @@
   GstH265NalUnit nalu;
   GstH265ParserResult parseres;
   GstCaps *old_caps;
+  /* this variable needs for passthrough mode when upstream want to do passthrough mode */
+  gboolean passthrough = FALSE;
 
   h265parse = GST_H265_PARSE (parse);
 
@@ -3070,6 +3072,9 @@
   gst_structure_get_fraction (str, "pixel-aspect-ratio",
       &h265parse->upstream_par_n, &h265parse->upstream_par_d);
 
+  /* check if upstream want to do passthrough mode */
+  gst_structure_get_boolean(str, "ring-mode", &passthrough);
+
   /* get upstream format and align from caps */
   gst_h265_parse_format_from_caps (caps, &format, &align);
 
@@ -3165,16 +3170,11 @@
     gst_caps_unref (in_caps);
   }
 
-  if (format == h265parse->format && align == h265parse->align) {
+  /* always set CAPS if passthrough mode (ring-mode) is on. */
+  if ((format == h265parse->format && align == h265parse->align) || passthrough) {
     /* do not set CAPS and passthrough mode if SPS/PPS have not been parsed */
-    if (h265parse->have_sps && h265parse->have_pps) {
-      /* Don't enable passthrough here. This element will parse various
-       * SEI messages which would be very important/useful for downstream
-       * (HDR, timecode for example)
-       */
-#if 0
+    if ((h265parse->have_sps && h265parse->have_pps) || passthrough) {
       gst_base_parse_set_passthrough (parse, TRUE);
-#endif
 
       /* we did parse codec-data and might supplement src caps */
       gst_h265_parse_update_src_caps (h265parse, caps);
diff -Naur 1.20.3-r0/gst-plugins-bad-1.20.3/gst-libs/gst/codecparsers/gsth265parser.c after/gst-libs/gst/codecparsers/gsth265parser.c
--- 1.20.3-r0/gst-plugins-bad-1.20.3/gst-libs/gst/codecparsers/gsth265parser.c	2022-06-16 07:36:22.000000000 +0900
+++ after/gst-libs/gst/codecparsers/gsth265parser.c	2022-11-07 17:25:45.843662556 +0900
@@ -601,7 +601,10 @@
 
 error:
   GST_WARNING ("error parsing \"VUI Parameters\"");
-  return FALSE;
+
+  /* Ignore VUI parsing error.
+     It can be reconfirmed in VPU.*/
+  return TRUE; // return FALSE;
 }
 
 static gboolean
