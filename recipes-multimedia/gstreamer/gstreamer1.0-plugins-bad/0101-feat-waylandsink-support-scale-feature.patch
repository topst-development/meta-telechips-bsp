From 98ee615082f841ad76033357d75397ce61b6a5e6 Mon Sep 17 00:00:00 2001
From: YoungJun <youngjun@telechips.com>
Date: Wed, 14 Jun 2023 11:07:43 +0900
Subject: [PATCH 1/3] [feat] waylandsink: support scale feature

- This feature supports that you can set the target window resolution.
  If target window is set, the difference between source and target make
  a scaling with viewporter protocol.
- The property is window-resolution and you can use with:
  waylandsink window-resolution="1920x720"

ITS : SD807XL-509

Change-Id: Ia6e69cb7cd8f0ba8e60a4568dc7d871b3171e7cc
---
 ext/wayland/gstwaylandsink.c | 24 +++++++++++++++++++++++-
 ext/wayland/gstwaylandsink.h |  1 +
 ext/wayland/wldisplay.h      |  2 ++
 ext/wayland/wlwindow.c       | 22 +++++++++++++++++++++-
 4 files changed, 47 insertions(+), 2 deletions(-)

diff --git a/ext/wayland/gstwaylandsink.c b/ext/wayland/gstwaylandsink.c
index 0761304..3871d7c 100644
--- a/ext/wayland/gstwaylandsink.c
+++ b/ext/wayland/gstwaylandsink.c
@@ -63,7 +63,8 @@ enum
 {
   PROP_0,
   PROP_DISPLAY,
-  PROP_FULLSCREEN
+  PROP_FULLSCREEN,
+  PROP_SCALE
 };
 
 GST_DEBUG_CATEGORY (gstwayland_debug);
@@ -212,6 +213,11 @@ gst_wayland_sink_class_init (GstWaylandSinkClass * klass)
           "Whether the surface should be made fullscreen ", FALSE,
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
+  g_object_class_install_property (gobject_class, PROP_SCALE,
+      g_param_spec_string ("window-resolution", "window resolution on display",
+          "resolution of video widthxheight ",
+          NULL, G_PARAM_WRITABLE | G_PARAM_STATIC_STRINGS));
+
   gst_type_mark_as_plugin_api (GST_TYPE_WAYLAND_VIDEO, 0);
 }
 
@@ -220,6 +226,7 @@ gst_wayland_sink_init (GstWaylandSink * sink)
 {
   g_mutex_init (&sink->display_lock);
   g_mutex_init (&sink->render_lock);
+  sink->scale_width = sink->scale_height = 0;
 }
 
 static void
@@ -262,6 +269,7 @@ gst_wayland_sink_set_property (GObject * object,
     guint prop_id, const GValue * value, GParamSpec * pspec)
 {
   GstWaylandSink *sink = GST_WAYLAND_SINK (object);
+  gchar *string = NULL, *end;
 
   switch (prop_id) {
     case PROP_DISPLAY:
@@ -274,6 +282,18 @@ gst_wayland_sink_set_property (GObject * object,
       gst_wayland_sink_set_fullscreen (sink, g_value_get_boolean (value));
       GST_OBJECT_UNLOCK (sink);
       break;
+   case PROP_SCALE:
+      GST_OBJECT_LOCK (sink);
+      string = g_value_dup_string (value);
+      sink->scale_width = g_ascii_strtoull (string, &end, 10);
+      if (*end != 'x')
+         sink->scale_width = 0;
+
+      sink->scale_height = g_ascii_strtoull (end+1, &end, 10);
+      if(string)
+          g_free(string);
+      GST_OBJECT_UNLOCK (sink);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -358,6 +378,8 @@ gst_wayland_sink_find_display (GstWaylandSink * sink)
         /* if the application didn't set a display, let's create it ourselves */
         GST_OBJECT_LOCK (sink);
         sink->display = gst_wl_display_new (sink->display_name, &error);
+        sink->display->scale_width = sink->scale_width;
+        sink->display->scale_height = sink->scale_height;
         GST_OBJECT_UNLOCK (sink);
 
         if (error) {
diff --git a/ext/wayland/gstwaylandsink.h b/ext/wayland/gstwaylandsink.h
index 7aabb6f..03cb9b5 100644
--- a/ext/wayland/gstwaylandsink.h
+++ b/ext/wayland/gstwaylandsink.h
@@ -63,6 +63,7 @@ struct _GstWaylandSink
   gboolean fullscreen;
 
   gchar *display_name;
+  gint scale_width, scale_height;
 
   gboolean redraw_pending;
   GMutex render_lock;
diff --git a/ext/wayland/wldisplay.h b/ext/wayland/wldisplay.h
index f2025a6..a713442 100644
--- a/ext/wayland/wldisplay.h
+++ b/ext/wayland/wldisplay.h
@@ -62,6 +62,8 @@ struct _GstWlDisplay
   struct zwp_linux_dmabuf_v1 *dmabuf;
   GArray *shm_formats;
   GArray *dmabuf_formats;
+  gint scale_width;
+  gint scale_height;
 
   /* private */
   gboolean own_display;
diff --git a/ext/wayland/wlwindow.c b/ext/wayland/wlwindow.c
index 66df0fc..46d162d 100644
--- a/ext/wayland/wlwindow.c
+++ b/ext/wayland/wlwindow.c
@@ -395,6 +395,8 @@ gst_wl_window_resize_video_surface (GstWlWindow * window, gboolean commit)
   GstVideoRectangle src = { 0, };
   GstVideoRectangle dst = { 0, };
   GstVideoRectangle res;
+  gint scale_width = window->display->scale_width;
+  gint scale_height = window->display->scale_height;
 
   /* center the video_subsurface inside area_subsurface */
   src.w = window->video_width;
@@ -402,8 +404,18 @@ gst_wl_window_resize_video_surface (GstWlWindow * window, gboolean commit)
   dst.w = window->render_rectangle.w;
   dst.h = window->render_rectangle.h;
 
+  if(scale_width > 0 && scale_height > 0)
+  {
+     res.x = 0;
+     res.y = 0;
+     res.w = scale_width;
+     res.h = scale_height;
+  }
+
   if (window->video_viewport) {
-    gst_video_sink_center_rect (src, dst, &res, TRUE);
+    /* if user input is none, align video to the center */
+    if (scale_width == 0)
+      gst_video_sink_center_rect (src, dst, &res, TRUE);
     wp_viewport_set_destination (window->video_viewport, res.w, res.h);
   } else {
     gst_video_sink_center_rect (src, dst, &res, FALSE);
@@ -541,8 +553,16 @@ void
 gst_wl_window_set_render_rectangle (GstWlWindow * window, gint x, gint y,
     gint w, gint h)
 {
+  gint scale_width = window->display->scale_width;
+  gint scale_height = window->display->scale_height;
+
   g_return_if_fail (window != NULL);
 
+  if(scale_width > 0 && scale_height > 0) {
+    w = scale_width;
+    h = scale_height;
+  }
+
   if (window->render_rectangle.x == x && window->render_rectangle.y == y &&
       window->render_rectangle.w == w && window->render_rectangle.h == h)
     return;
-- 
2.25.1

