[mod] gstreamer1.0-plugins-good (avidemux, qtdemux, wavparse)
avidemux - 1) set pts also
           2) support vbraudio
           3) support vorbis
qtdemux - 1) use JPU for jpeg decoding
          2) use dts for audio & video decoding
wavparse - check null buffer at gst_wavparse_cue_chuck() : IS004A-13200 (WAV)

diff --git a/gst/avi/gstavidemux.c b/gst/avi/gstavidemux.c
index b4616a6..bec056c 100644
--- a/gst/avi/gstavidemux.c
+++ b/gst/avi/gstavidemux.c
@@ -494,11 +494,18 @@ gst_avi_demux_handle_src_query (GstPad * pad, GstObject * parent,
           guint64 xlen = avi->avih->us_frame *
               avi->avih->tot_frames * GST_USECOND;
 
-          pos = gst_util_uint64_scale (xlen, stream->current_total,
-              stream->total_bytes);
-          GST_DEBUG_OBJECT (avi,
-              "CBR perc convert bytes %u, time %" GST_TIME_FORMAT,
-              stream->current_total, GST_TIME_ARGS (pos));
+          if (stream->is_vbr) {
+            pos = gst_util_uint64_scale (xlen, stream->current_entry,
+                stream->idx_n);
+            GST_DEBUG_OBJECT (avi, "VBR perc convert frame %u, time %"
+                GST_TIME_FORMAT, stream->current_entry, GST_TIME_ARGS (pos));
+          } else {
+            pos = gst_util_uint64_scale (xlen, stream->current_total,
+                stream->total_bytes);
+            GST_DEBUG_OBJECT (avi,
+                "CBR perc convert bytes %u, time %" GST_TIME_FORMAT,
+                stream->current_total, GST_TIME_ARGS (pos));
+          }
         } else {
           /* we don't know */
           res = FALSE;
@@ -1351,25 +1358,10 @@ gst_avi_demux_add_index (GstAviDemux * avi, GstAviStream * stream,
 
   /* update entry total and stream stats. The entry total can be converted to
    * the timestamp of the entry easily. */
-  if (stream->strh->type == GST_RIFF_FCC_auds) {
-    gint blockalign;
-
-    if (stream->is_vbr) {
-      entry->total = stream->total_blocks;
-    } else {
-      entry->total = stream->total_bytes;
-    }
-    blockalign = stream->strf.auds->blockalign;
-    if (blockalign > 0)
-      stream->total_blocks += DIV_ROUND_UP (entry->size, blockalign);
-    else
-      stream->total_blocks++;
+  if (stream->is_vbr) {
+    entry->total = stream->idx_n;
   } else {
-    if (stream->is_vbr) {
-      entry->total = stream->idx_n;
-    } else {
-      entry->total = stream->total_bytes;
-    }
+    entry->total = stream->total_bytes;
   }
   stream->total_bytes += entry->size;
   if (ENTRY_IS_KEYFRAME (entry))
@@ -1999,9 +1991,108 @@ gst_avi_demux_check_caps (GstAviDemux * avi, GstAviStream * stream,
         gst_buffer_unmap (buf, &map);
       }
     }
-  }
+    return caps;
+  } else if (gst_structure_has_name (s, "audio/x-vorbis")) {
+    /* vorbis audio, need to send the codec_priv data as first three packets */
+    val = gst_structure_get_value (s, "codec_data");
+    if (val && (buf = gst_value_get_buffer (val))) {
+      guint8 *data_ptr;
+      gint data_len;
+      GstMapInfo map;
+
+      gst_buffer_map (buf, &map, GST_MAP_READ);
+      data_ptr = map.data;
+      data_len = map.size;
+
+      if (data_ptr && data_len > 0) {
+        GstBufferList *list = NULL;
+        guint8 *p = data_ptr;
+        gint i, num, exlen, run;
+        guint length[3];
+        guint8 *pData[3];
+        GstStructure *s;
+        GValue arr_val = G_VALUE_INIT;
+        GValue buf_val = G_VALUE_INIT;
+
+        g_assert (gst_caps_is_writable (caps));
+        GST_DEBUG_OBJECT (avi,"data_len %d codec_data %s", data_len, data_ptr);
+
+        /* start of the stream and vorbis audio, need to
+         * send the codec_priv data as first three packets */
+        exlen = data_len;
+        run = 0;
+        while (run < exlen) {
+          if (((p[0]==1) || (p[0]==3) || (p[0]==5)) &&
+               (p[1] == 'v') && (p[2] == 'o') && (p[3] == 'r') && (p[4] == 'b') &&	(p[5] == 'i') && (p[6] == 's')) {
+            break;
+          }
+          run++;	p++;
+        }
+        pData[0] = p;
+
+        run = 7;
+        p += run;
+        exlen -= run;
+        while (run < exlen) {
+          if (((p[0]==1) || (p[0]==3) || (p[0]==5)) &&
+               (p[1] == 'v') && (p[2] == 'o') && (p[3] == 'r') && (p[4] == 'b') &&	(p[5] == 'i') && (p[6] == 's')) {
+            break;
+          }
+          run++;	p++;
+        }
+        pData[1] = p;
+        length[0] = run;
+
+        run = 7;
+        p += run;
+        exlen -= run;
+        while (run < exlen) {
+          if (((p[0]==1) || (p[0]==3) || (p[0]==5)) &&
+               (p[1] == 'v') && (p[2] == 'o') && (p[3] == 'r') && (p[4] == 'b') &&	(p[5] == 'i') && (p[6] == 's')) {
+            break;
+          }
+          run++;	p++;
+        }
+        pData[2] = p;
+        length[1] = run;
 
-  return caps;
+        exlen -= run;
+        length[2] = exlen;
+
+        list = gst_buffer_list_new ();
+
+        for (i=0; i<3; i++) {
+          GstBuffer *hdr;
+          GST_DEBUG_OBJECT (avi,"buffer %d: %u bytes", i, (guint) length[i]);
+          hdr = gst_buffer_new_wrapped (g_memdup (pData[i], length[i]), length[i]);
+          gst_buffer_list_add (list, hdr);
+        }
+
+        g_value_init (&arr_val, GST_TYPE_ARRAY);
+        g_value_init (&buf_val, GST_TYPE_BUFFER);
+
+        num = gst_buffer_list_length (list);
+
+        for (i = 0; i < num; ++i) {
+          g_value_set_boxed (&buf_val, gst_buffer_list_get (list, i));
+          gst_value_array_append_value (&arr_val, &buf_val);
+        }
+
+        s = gst_caps_get_structure (caps, 0);
+        gst_structure_set_value (s, "streamheader", &arr_val);
+        g_value_unset (&buf_val);
+        g_value_unset (&arr_val);
+
+        if (list != NULL)
+          gst_buffer_list_unref (list);
+      }
+
+      gst_buffer_unmap (buf, &map);
+      return caps;
+    }
+  }
+  else
+    return caps;
 }
 
 /*
@@ -2139,10 +2230,20 @@ gst_avi_demux_parse_stream (GstAviDemux * avi, GstBuffer * buf)
             sub = NULL;
             if (!res)
               break;
+
+            // ENFORCE VBR CASE. WHEN ulBlockAlign has big value. Not sure about this. I FOUND THAT AAC_VBR(ABR) HAS 4096 FOR THIS VALUE.
+            // SOMEONE SAID THAT MICROSOFT AVI USES nBlockAlign only to detect VBR AUDIO. SO, LET'S TRY IT.
+            if ((stream->strf.auds->blockalign >= 4096) ||
+                (stream->strf.auds->format == 0xff && (stream->strf.auds->blockalign >= 1024)) || //aac
+                ((stream->strf.auds->format >= 0x160) && (stream->strf.auds->format <= 0x163)) // wma
+            )
+              stream->strh->samplesize = 0;
+
             stream->is_vbr = (stream->strh->samplesize == 0)
-                && stream->strh->scale > 1
-                && stream->strf.auds->blockalign != 1;
-            GST_DEBUG_OBJECT (element, "marking audio as VBR:%d, res %d",
+                && stream->strh->scale
+                && stream->strf.auds->blockalign != 1
+                && ((stream->strh->rate/stream->strh->scale) != stream->strf.auds->av_bps);
+            GST_INFO_OBJECT (element, "marking audio as VBR:%d, res %d",
                 stream->is_vbr, res);
             /* we need these or we have no way to come up with timestamps */
             if ((!stream->is_vbr && !stream->strf.auds->av_bps) ||
@@ -2355,6 +2456,7 @@ gst_avi_demux_parse_stream (GstAviDemux * avi, GstBuffer * buf)
         caps = gst_caps_new_simple ("audio/x-avi-unknown", "codec_id",
             G_TYPE_INT, stream->strf.auds->format, NULL);
       }
+      caps = gst_avi_demux_check_caps (avi, stream, caps);
       tag_name = GST_TAG_AUDIO_CODEC;
       avi->num_a_streams++;
       break;
@@ -5325,7 +5427,7 @@ gst_avi_demux_loop_data (GstAviDemux * avi)
     }
 
     GST_BUFFER_DTS (buf) = timestamp;
-
+    GST_BUFFER_PTS (buf) = timestamp;
     GST_BUFFER_DURATION (buf) = duration;
     GST_BUFFER_OFFSET (buf) = out_offset;
     GST_BUFFER_OFFSET_END (buf) = out_offset_end;
@@ -5372,6 +5474,13 @@ gst_avi_demux_loop_data (GstAviDemux * avi)
     /* move to next item */
     ret = gst_avi_demux_advance (avi, stream, ret);
 
+	if((ret == GST_FLOW_EOS) && (stream->pad))
+	{
+		GstEvent *pstEvent = gst_event_new_eos();
+		GST_DEBUG_OBJECT(avi,"Set EOS to stream %d ",stream_num);
+		gst_pad_push_event (stream->pad, gst_event_ref(pstEvent));
+		gst_event_unref(pstEvent);
+	}
     /* combine flows */
     ret = gst_avi_demux_combine_flows (avi, stream, ret);
   } while (!processed);
@@ -5593,11 +5702,7 @@ gst_avi_demux_stream_data (GstAviDemux * avi)
         stream->current_entry++;
         /* as in pull mode, 'total' is either bytes (CBR) or frames (VBR) */
         if (stream->strh->type == GST_RIFF_FCC_auds && stream->is_vbr) {
-          gint blockalign = stream->strf.auds->blockalign;
-          if (blockalign > 0)
-            stream->current_total += DIV_ROUND_UP (size, blockalign);
-          else
-            stream->current_total++;
+          stream->current_total++;
         } else {
           stream->current_total += size;
         }
@@ -5798,6 +5903,38 @@ pause:{
       GST_ELEMENT_FLOW_ERROR (avi, res);
       push_eos = TRUE;
     }
+    else if(res == GST_FLOW_FLUSHING)
+    {
+      GstState state;
+      GstState pending;
+      GstStateChangeReturn ret;
+      ret = gst_element_get_state (GST_ELEMENT_CAST (avi), &state,&pending,0);
+      GST_INFO_OBJECT (avi, "\x1b[1;32m ret = %d, state = %d, pending = %d \x1b[1;0m",
+                    ret, state,pending);
+
+      if(ret == GST_STATE_CHANGE_SUCCESS &&
+        state == GST_STATE_PAUSED &&
+        pending == GST_STATE_VOID_PENDING)
+      {
+        // decodebin
+        GstElement *parentElement = gst_element_get_parent(GST_ELEMENT_CAST (avi));
+        if(parentElement != NULL)
+        {
+          ret = gst_element_get_state (GST_ELEMENT_CAST (parentElement), &state,&pending,0);
+          GST_ERROR_OBJECT (parentElement, "\x1b[1;33m ret = %d, state = %d, pending = %d \x1b[1;0m", ret, state,pending);
+
+          if(ret == GST_STATE_CHANGE_ASYNC &&
+            state == GST_STATE_READY &&
+            pending == GST_STATE_PAUSED)
+          {
+            GST_ELEMENT_ERROR (avi, STREAM, FAILED,
+              (_("flushing.")),
+              ("streaming stopped, reason %s", gst_flow_get_name (res)));
+          }
+        }
+        gst_object_unref (parentElement);
+      }
+    }
     if (push_eos) {
       GstEvent *event;
 
diff --git a/gst/isomp4/qtdemux.c b/gst/isomp4/qtdemux.c
index f6f39de..a91ad39 100644
--- a/gst/isomp4/qtdemux.c
+++ b/gst/isomp4/qtdemux.c
@@ -5240,6 +5240,11 @@ gst_qtdemux_prepare_current_sample (GstQTDemux * qtdemux,
   *duration = QTSAMPLE_DUR_DTS (stream, sample, *dts);
   *keyframe = QTSAMPLE_KEYFRAME (stream, sample);
 
+  if (((stream->subtype == FOURCC_soun) //audio stream's timestamp don't need ordering
+    || (stream->subtype == FOURCC_vide)) && (*dts != -1)) //video stream's timestamp also don't need ordering (omxvideodec can sort timestamp)
+  {
+    *pts = *dts;
+  }
   return TRUE;
 
   /* special cases */
@@ -6757,6 +6762,38 @@ pause:
       GST_ELEMENT_FLOW_ERROR (qtdemux, ret);
       gst_qtdemux_push_event (qtdemux, gst_event_new_eos ());
     }
+    else if(ret == GST_FLOW_FLUSHING)
+    {
+      GstState state;
+      GstState pending;
+      GstStateChangeReturn ret;
+      ret = gst_element_get_state (GST_ELEMENT_CAST (qtdemux), &state,&pending,0);
+      GST_INFO_OBJECT (qtdemux, "\x1b[1;32m ret = %d, state = %d, pending = %d \x1b[1;0m", ret, state,pending);
+
+      if(ret == GST_STATE_CHANGE_SUCCESS &&
+        state == GST_STATE_PAUSED &&
+        pending == GST_STATE_VOID_PENDING)
+      {
+        // decodebin
+        GstElement *parentElement = gst_element_get_parent(GST_ELEMENT_CAST (qtdemux));
+        if(parentElement != NULL)
+        {
+          ret = gst_element_get_state (GST_ELEMENT_CAST (parentElement), &state,&pending,0);
+          GST_ERROR_OBJECT (parentElement, "\x1b[1;33m ret = %d, state = %d, pending = %d \x1b[1;0m",
+                        ret, state,pending);
+
+          if(ret == GST_STATE_CHANGE_ASYNC &&
+            state == GST_STATE_READY &&
+            pending == GST_STATE_PAUSED)
+          {
+            GST_ELEMENT_ERROR (qtdemux, STREAM, FAILED,
+              (_("flushing.")),
+              ("streaming stopped, reason %s", gst_flow_get_name (ret)));
+          }
+        }
+        gst_object_unref (parentElement);
+      }
+    }
     goto done;
   }
 }
@@ -9390,7 +9427,7 @@ qtdemux_stbl_init (GstQTDemux * qtdemux, QtDemuxStream * stream, GNode * stbl)
     goto corrupt_file;
 
   /* chunks_are_samples == TRUE means treat chunks as samples */
-  stream->chunks_are_samples = stream->sample_size
+  stream->chunks_are_samples = (stream->sample_size == 1)
       && !CUR_STREAM (stream)->sampled;
   if (stream->chunks_are_samples) {
     /* treat chunks as samples */
@@ -10200,8 +10237,14 @@ done:
 
   /* no segments, create one to play the complete trak */
   if (stream->n_segments == 0) {
+    /* compensate a stream duration by using stts's time. It's more correct than segment's time */
+    if (stream->n_samples &&
+        !qtdemux_parse_samples (qtdemux, stream, stream->n_samples - 1)) {
+      stream->stts_time = 0;
+    }
+
     GstClockTime stream_duration =
-        QTSTREAMTIME_TO_GSTTIME (stream, stream->duration);
+        gst_util_uint64_scale (MAX (stream->stts_time, stream->duration), GST_SECOND, stream->timescale);
 
     if (stream->segments == NULL)
       stream->segments = g_new (QtDemuxSegment, 1);
@@ -11487,6 +11530,7 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
 
               switch (QT_FOURCC (hevc_data + 0x4)) {
                 case FOURCC_hvcC:
+                case FOURCC_glbl:
                 {
                   /* parse, if found */
                   GstBuffer *buf;
@@ -14220,7 +14264,7 @@ gst_qtdemux_handle_esds (GstQTDemux * qtdemux, QtDemuxStream * stream,
       break;
     case 0x6C:                 /* MJPEG */
       caps =
-          gst_caps_new_simple ("image/jpeg", "parsed", G_TYPE_BOOLEAN, TRUE,
+          gst_caps_new_simple ("video/x-jpeg", "parsed", G_TYPE_BOOLEAN, TRUE,
           NULL);
       codec_name = "Motion-JPEG";
       break;
@@ -14355,7 +14399,7 @@ qtdemux_video_caps (GstQTDemux * qtdemux, QtDemuxStream * stream,
     case FOURCC_jpeg:
       _codec ("JPEG still images");
       caps =
-          gst_caps_new_simple ("image/jpeg", "parsed", G_TYPE_BOOLEAN, TRUE,
+          gst_caps_new_simple ("video/x-jpeg", "parsed", G_TYPE_BOOLEAN, TRUE,
           NULL);
       break;
     case GST_MAKE_FOURCC ('m', 'j', 'p', 'a'):
@@ -14364,7 +14408,7 @@ qtdemux_video_caps (GstQTDemux * qtdemux, QtDemuxStream * stream,
     case GST_MAKE_FOURCC ('d', 'm', 'b', '1'):
       _codec ("Motion-JPEG");
       caps =
-          gst_caps_new_simple ("image/jpeg", "parsed", G_TYPE_BOOLEAN, TRUE,
+          gst_caps_new_simple ("video/x-jpeg", "parsed", G_TYPE_BOOLEAN, TRUE,
           NULL);
       break;
     case GST_MAKE_FOURCC ('m', 'j', 'p', 'b'):
diff --git a/gst/wavparse/gstwavparse.c b/gst/wavparse/gstwavparse.c
index 4a7be71..6a7498d 100644
--- a/gst/wavparse/gstwavparse.c
+++ b/gst/wavparse/gstwavparse.c
@@ -789,6 +789,11 @@ gst_wavparse_cue_chunk (GstWavParse * wav, const guint8 * data, guint32 size)
     return TRUE;
   }
 
+  if (data == NULL) {
+    GST_WARNING_OBJECT (wav, "broken file data %p, size %d", data, size);
+    return FALSE;
+  }
+
   ncues = GST_READ_UINT32_LE (data);
 
   if (size < 4 + ncues * 24) {
